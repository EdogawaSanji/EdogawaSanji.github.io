<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>STL 标准模板库 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="STL 标准模版库六大部件 容器 (Containers) 分配器(Allocators) 算法(Algorithms) 迭代器(Iterators) 适配器(Adapters) 仿函式(Functors)  容器的分类顺序容器 Array 数组；无法扩充   Vector 向量；double 扩充，每次扩充都需寻找新的双倍内存   Deque 双向列表：分段连续；存储连续的内存块。每次扩充一个">
<meta property="og:type" content="article">
<meta property="og:title" content="STL 标准模板库">
<meta property="og:url" content="http://example.com/2021/02/27/STL-%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="STL 标准模版库六大部件 容器 (Containers) 分配器(Allocators) 算法(Algorithms) 迭代器(Iterators) 适配器(Adapters) 仿函式(Functors)  容器的分类顺序容器 Array 数组；无法扩充   Vector 向量；double 扩充，每次扩充都需寻找新的双倍内存   Deque 双向列表：分段连续；存储连续的内存块。每次扩充一个">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-02-27T15:49:21.000Z">
<meta property="article:modified_time" content="2021-02-27T15:51:00.968Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-STL-标准模板库" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/27/STL-%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/" class="article-date">
  <time class="dt-published" datetime="2021-02-27T15:49:21.000Z" itemprop="datePublished">2021-02-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      STL 标准模板库
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="STL-标准模版库"><a href="#STL-标准模版库" class="headerlink" title="STL 标准模版库"></a>STL 标准模版库</h1><h1 id="六大部件"><a href="#六大部件" class="headerlink" title="六大部件"></a>六大部件</h1><ul>
<li>容器 (Containers)</li>
<li>分配器(Allocators)</li>
<li>算法(Algorithms)</li>
<li>迭代器(Iterators)</li>
<li>适配器(Adapters)</li>
<li>仿函式(Functors)</li>
</ul>
<h1 id="容器的分类"><a href="#容器的分类" class="headerlink" title="容器的分类"></a>容器的分类</h1><h2 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h2><ul>
<li>Array<ul>
<li>数组；无法扩充</li>
</ul>
</li>
<li>Vector<ul>
<li>向量；double 扩充，每次扩充都需寻找新的双倍内存</li>
</ul>
</li>
<li>Deque<ul>
<li>双向列表：分段连续；存储连续的内存块。每次扩充一个 buffer_size</li>
<li>queue，stack 底层实现（Adapter）</li>
</ul>
</li>
<li>List<ul>
<li>链表；动态扩充</li>
</ul>
</li>
<li>Forward-List<ul>
<li>单向链表</li>
</ul>
</li>
</ul>
<h2 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h2><ul>
<li>Set/Multiset<ul>
<li>底层由 map 实现</li>
</ul>
</li>
<li>Map/Multimap</li>
<li>UnorderedMap/UnorderedSet</li>
</ul>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><ul>
<li>双向环状链表</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;GNU <span class="number">2.9</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  list_node* node;     <span class="comment">// sizeof list = 4</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_node</span> &#123;</span></span><br><span class="line"> 	<span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;</span><br><span class="line">  void_pointer prev;</span><br><span class="line">  void_pointer next;</span><br><span class="line">  T data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&lt;GNU <span class="number">4.9</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span> :</span>: _List_Base &#123;  <span class="comment">// size of list = 8 (_List_node_base)</span></span><br><span class="line">  _List_Impl _M_impl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">List_Impl</span> &#123;</span></span><br><span class="line">  _List_node_base _M_node;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">List_node_base</span> &#123;</span></span><br><span class="line">  _List_node_base *_M_prev;</span><br><span class="line">  _List_node_base *_M_next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>Iterator : </li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>&gt;</span>      &lt;GNU <span class="number">2.9</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_iterator</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> list_iterator&lt;T, Ref, Ptr&gt; self;        <span class="comment">// 定义返回类型</span></span><br><span class="line">  <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">  <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">  <span class="keyword">typedef</span> list_node&lt;T&gt;* link_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> different_type;</span><br><span class="line">  </span><br><span class="line">  link_type node;</span><br><span class="line">  </span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;<span class="keyword">return</span> (*node).data;&#125;</span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;<span class="keyword">return</span> &amp;(*<span class="keyword">operator</span>*());&#125;</span><br><span class="line">  <span class="comment">// 前置 ++；可以累加</span></span><br><span class="line">  self&amp; <span class="keyword">operator</span>++() &#123;node = (link_type)((*node).next); <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">  <span class="comment">// 后置 ++；不可累加</span></span><br><span class="line">  self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;self tmp = *<span class="keyword">this</span>; ++*<span class="keyword">this</span>; <span class="keyword">return</span> tmp;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List_pointer</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> _Tp* pointer;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp&amp; reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;               &lt;GNU <span class="number">2.9</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* Iterator;</span><br><span class="line">  <span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line"><span class="keyword">protected</span>:											<span class="comment">// size of vector = 12</span></span><br><span class="line">	Iterator start;</span><br><span class="line">  Iterator finish;</span><br><span class="line">  Iterator end_of_storage;      <span class="comment">// 内存空间终点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><ul>
<li>便于使用算法、仿函数等</li>
<li>iterator 是 指针</li>
</ul>
<h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">deque_terator</span> &#123;</span></span><br><span class="line">  T *cur;          <span class="comment">// 本段当前位置</span></span><br><span class="line">  T *first;        <span class="comment">// 本段起始位置</span></span><br><span class="line">  T *last;					<span class="comment">// 本段末尾位置</span></span><br><span class="line">  map_pointer node;         <span class="comment">// 指向段控制中心，用于移动到下一分段</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">deque</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">typedef</span> pointer* map_pointer;</span><br><span class="line">  _deque_terator start;</span><br><span class="line">  _deque_terator finish;</span><br><span class="line">  map_pointer <span class="built_in">map</span>;         <span class="comment">// 段控制中心：vector：扩充时，原 vector 拷贝至中段</span></span><br><span class="line">  size_type map_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>queue（list、vector 也可为其底层结构）</li>
<li>stack （vector 也可为其底层结构）</li>
</ul>
<h2 id="rb-Tree"><a href="#rb-Tree" class="headerlink" title="rb Tree"></a>rb Tree</h2><ul>
<li>遍历：++ iterator：中序遍历</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">KeyOfValue</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span>=</span>alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rb_tree</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">typedef</span> _rb_tree_node&lt;Value&gt; rb_tree_node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> rb_tree_node* link_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  size_type node_count; 		<span class="comment">// rb_tree 的大小</span></span><br><span class="line">  link_type header;					<span class="comment">// rb_tree 根节点</span></span><br><span class="line">  Compare key_compare;			<span class="comment">// key 的比较函数（仿函数）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul>
<li>无法使用 iterator 改变元素值：const iterator 防止改变排序</li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Compare</span> =</span> less&lt;Key&gt;, <span class="class"><span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">map</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">  <span class="keyword">typedef</span> T data_type;</span><br><span class="line">  <span class="keyword">typedef</span> T mapped_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">const</span> Key, T&gt; value_type;			<span class="comment">// rb tree 所存值：key 值不可变</span></span><br><span class="line">  <span class="keyword">typedef</span> Compare key_compare;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">typedef</span> rb_tree&lt;key_type, value_type, select1st&lt;value_type&gt;, key_compare, Alloc&gt; rep_type;</span><br><span class="line">  <span class="comment">// select1st：取 pair 的 first</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator iterator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">mapped_type &amp;<span class="keyword">operator</span> [](<span class="keyword">const</span> key_type &amp;key)&#123;</span><br><span class="line">  iterator i = lower_bound(key);										<span class="comment">// 先查找</span></span><br><span class="line">  <span class="keyword">if</span> (i == end())&#123;																	<span class="comment">// 再调用insert</span></span><br><span class="line">    i = insert(i, value_type(k, mapped_type));</span><br><span class="line">    <span class="keyword">return</span> i.second;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="hash-table"><a href="#hash-table" class="headerlink" title="hash_table"></a>hash_table</h2><ul>
<li>hash_size：质数</li>
<li>当拉链元素数大于 hash_size，取 2*hash_size 附近的质数；重新计算散列</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">HashFcn</span>, <span class="keyword">class</span> <span class="title">ExtractKey</span>, <span class="keyword">class</span> <span class="title">EqualKey</span>, <span class="keyword">class</span> <span class="title">Alloc</span>=</span>alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hashtable</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> HashFcn hasher;</span><br><span class="line">  <span class="keyword">typedef</span> EqualKey key_equal;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  hasher hash;</span><br><span class="line">  key_equal equals;</span><br><span class="line">  ExtractKey get_key;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">typedef</span> __hashtable_node&lt;Value&gt; node;</span><br><span class="line">  <span class="built_in">vector</span>&lt;node*, Alloc&gt; buckets;</span><br><span class="line">  size_type num_elements;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> buckets.size();&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">hashtable_iterator</span> &#123;</span></span><br><span class="line">  node* cur;</span><br><span class="line">  hasbtable* ht; <span class="comment">// 指向控制中心，方便回查</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h1 id="OOP（面向对象编程）和GP（泛型编程）"><a href="#OOP（面向对象编程）和GP（泛型编程）" class="headerlink" title="OOP（面向对象编程）和GP（泛型编程）"></a>OOP（面向对象编程）和GP（泛型编程）</h1><ul>
<li>OOP：力图将 data 与 method 关联在一起<ul>
<li>操作符重载：<ul>
<li>a * b :<ul>
<li>类成员函数：(a).operator* (b)</li>
<li>普通函数：operator* (a,b)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>GP：力图将 data 与 method 分开来<ul>
<li>不同模块间通过某个 function &amp; variable 连接；模块内部可以任意变动</li>
<li>模板：<ul>
<li>函数模板</li>
<li>类模板</li>
<li>泛化及特化：<ul>
<li>泛化：template <typename T> struct mmd{};</li>
<li>特化：template&lt;&gt; struct mmd<int> {};   特化 int 型</li>
<li>偏特化：特化指针类型<ul>
<li>tempalte<typename TT> struct mmd&lt;TT*&gt;{};</li>
<li>tempalte<typename TT> struct mmd&lt;const TT*&gt;{};</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="分配器"><a href="#分配器" class="headerlink" title="分配器"></a>分配器</h1><ul>
<li>std::allocator&lt;&gt;                                   标准库</li>
<li>_gnu_cxx::malloc_allocator&lt;&gt;          #include &lt;ext/malloc_allocator.h&gt;</li>
<li>_gnu_cxx::array_allocator&lt;&gt;            #include &lt;ext/array_allocator.h&gt;</li>
<li>_gnu_cxx::mt_alloc&lt;&gt;                        #include &lt;ext/mt_allocator.h&gt;</li>
<li>_gnu_cxx::pool_alloc&lt;&gt;                     #include &lt;ext/pool_allocator.h&gt;</li>
<li>_gnu_cxx::debug_allocator&lt;&gt;          #include &lt;ext/debug_allocator.h&gt;</li>
<li>_gnu_cxx::bitmap_allocator&lt;&gt;         #include &lt;ext/bitmap_allocator.h&gt;</li>
<li>_gnu_cxx::new_allocator&lt;&gt;              #include &lt;ext/new_allocator.h&gt;</li>
</ul>
<h1 id="Allocators"><a href="#Allocators" class="headerlink" title="Allocators"></a>Allocators</h1><ul>
<li>operator new 和 malloc</li>
<li>operator delete 和 free</li>
</ul>
<h1 id="Iterator-Traits"><a href="#Iterator-Traits" class="headerlink" title="Iterator Traits"></a>Iterator Traits</h1><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><ul>
<li>必须提供5种 associated type</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>&gt;</span> 							&lt;GNU <span class="number">2.9</span>&gt;</span><br><span class="line">Iterator&#123;</span><br><span class="line">  <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;    <span class="comment">// 迭代器移动性质，是否可以回退，是否可以跳 N 隔等</span></span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">  <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> different_type;												 <span class="comment">// Iterator 之间的距离可以用什么表示（Int 等）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>iterator_category:</p>
<ul>
<li><p>random_access_iterator_tag：随机访问迭代器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">random_access_iterator_tag</span> :</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bidirectional_iterator_tag</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>bidirectional_iterator_tag：双向访问迭代器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bidirectional_iterator_tag</span> :</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">forward_iterator_tag</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>forward_iterator_tag：单向访问迭代器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">forward_iterator_tag</span> :</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">input_iterator_tag</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>input_iterator_tag：迭代器的 base</p>
</li>
<li><p>output_iterator_tag：左值迭代器</p>
</li>
</ul>
</li>
<li><p>Iterator Traits</p>
<ul>
<li>为了使得==指针==类型也可以回答算法的提问，设计的一种偏特化</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> I::different_type different_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;</span>T *&gt; &#123;</span><br><span class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> T* pointer;</span><br><span class="line">  <span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> different_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;</span><span class="keyword">const</span> T *&gt; &#123;</span><br><span class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> T value_type;																		<span class="comment">// 一般用于声明变量，声明一个无法被赋值的变量无意义</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> T* pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> T&amp; reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> different_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="category-对于算法的影响"><a href="#category-对于算法的影响" class="headerlink" title="category 对于算法的影响"></a>category 对于算法的影响</h2><ul>
<li><p>random_access_iterator_tag：对于随机访问迭代器做了优化</p>
</li>
<li><pre><code class="c++">// 对外接口，interface
template &lt;class InputIterator, class Distance&gt;
inline iterator_traits&lt;InputIterator&gt;::difference_type 
distance(InputIterator first, InputIterator last) &#123;
  typedef typename iterator_traits&lt;InputIterator&gt;::iterator_category category;
  return _distance(first, last, category());
&#125;

// 针对随机访问迭代器的优化
template &lt;class RandomAccessIterator&gt;
inline iterator_traits&lt;RandomAccessIterator&gt;::difference_type 
_distance(RandomAccessIterator first, RandomAccessIterator last, random_access_iterator_tag) &#123;
  return last - first;
&#125;

// 其他 category 的迭代器
template &lt;class InputIterator&gt;
inline iterator_traits&lt;InputIterator&gt;::difference_type 
_distance(InputIterator first, InputIterator last, input_iterator_tag) &#123;
    iterator_traits&lt;InputIterator&gt;::difference_type n = 0;
  while (first != last) &#123;
    ++ first;
    ++ n;
  &#125;
  return n;
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 仿函数 functors（函数对象）</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;c++</span><br><span class="line">&#x2F;&#x2F; 1. functors</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">struct function_x : public binary_function&lt;T, T, T&gt;&#123;</span><br><span class="line">  T operator() (const T&amp; x, const T&amp; y) &#123;;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">sort (vector.begin(), vector.end(), function_x&lt;int&gt;());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. struct</span><br><span class="line">struct function_y &#123;</span><br><span class="line">  bool operator() (int x, int y) &#123;;&#125;</span><br><span class="line">&#125; obj;</span><br><span class="line">sort (vector.begin(), vector.end(), obj);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3. function</span><br><span class="line">bool function_z (int x, int y) &#123;;&#125;</span><br><span class="line">sort (vector.begin(), vector.end(), function_z);</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<h2 id="binary-function"><a href="#binary-function" class="headerlink" title="binary_function"></a>binary_function</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg1</span>, <span class="keyword">class</span> <span class="title">Arg2</span>, <span class="keyword">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binary_function</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> Arg1 first_argument_type;</span><br><span class="line">  <span class="keyword">typedef</span> Arg2 second_argument_type;</span><br><span class="line">  <span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="unary-function"><a href="#unary-function" class="headerlink" title="unary_function"></a>unary_function</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg</span>, <span class="keyword">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unary_function</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> Arg argument_type;</span><br><span class="line">  <span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h1 id="适配器-Adapter"><a href="#适配器-Adapter" class="headerlink" title="适配器 Adapter"></a>适配器 Adapter</h1><ul>
<li>与算法交互：容器适配器、迭代器适配器、函数适配器</li>
<li>容器适配器：stack、queue</li>
<li>函数适配器</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. binder2nd：绑定第二参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Operation</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> binder2nd&lt;Operation&gt; <span class="title">bind2nd</span><span class="params">(<span class="keyword">const</span> Operation&amp; op, <span class="keyword">const</span> T &amp;x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Operation::second_argument_type arg2_type;			<span class="comment">// 自动推导第二实参类型</span></span><br><span class="line">  <span class="keyword">return</span> binder2nd&lt;Operation&gt;(op, arg2_type(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Operation</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">binder2nd</span>	:</span> <span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> Operation::first_argument_type, <span class="keyword">typename</span> Operation::result_type&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Operation op;</span><br><span class="line">  <span class="keyword">typename</span> Operation::second_argument_type value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 记住第二参数</span></span><br><span class="line">  binder2nd (<span class="keyword">const</span> Operation&amp; x, <span class="keyword">const</span> <span class="keyword">typename</span> Operation::second_argument_type value &amp;y&gt; : op(x), value(y) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">typename</span> Operation::result_type</span><br><span class="line">  <span class="keyword">operator</span>() (<span class="keyword">const</span> <span class="keyword">typename</span> Operation::first_argument_type &amp;x) &#123;</span><br><span class="line">    <span class="keyword">return</span> op(x, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>迭代器适配器：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">reverse_iterator</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Iterator current;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::iterator_category iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::value_type value_type;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">typedef</span> Iterator iterator_type;</span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;Iterator&gt; self;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  reference <span class="keyword">operator</span> *() <span class="keyword">const</span> &#123;Iterator tmp = current; <span class="keyword">return</span> *--tmp;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Container</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">insert_interator</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Container *container;</span><br><span class="line">  <span class="keyword">typename</span> Container::iterator iter;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> output_iterator_tag iterator_category;</span><br><span class="line">  insert_interator(Container&amp; x, <span class="keyword">typename</span> Container::iterator i): Container(&amp;x), iter(i)&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  insert_interator&lt;Container&gt;&amp; <span class="keyword">operator</span> =(<span class="keyword">const</span> <span class="keyword">typename</span> Container::value_type&amp; value) &#123;</span><br><span class="line">    iter = container-&gt;insert(iter, value);</span><br><span class="line">    ++ iter;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h1><ul>
<li>like pair：多元元素组</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Values&gt; <span class="class"><span class="keyword">class</span> <span class="title">tuple</span>;</span>    <span class="comment">// GNU 4.8</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">tuple</span>&lt;</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tuple</span>&lt;</span>Head, Tail...&gt; : <span class="keyword">private</span> tuple&lt;Tail...&gt; &#123;</span><br><span class="line">	<span class="keyword">typedef</span> tuple&lt;Tail...&gt; inherited;								<span class="comment">// 继承 tail 构造的父类</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Head m_head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  tuple(Head v, Tail... vtail) : m_head(v), inherited(vtail...) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">typename</span> Head::type <span class="title">head</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_head&#125;;</span><br><span class="line">  <span class="function">inherited&amp; <span class="title">tail</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> *<span class="keyword">this</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="type-traits"><a href="#type-traits" class="headerlink" title="type traits"></a>type traits</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span>								<span class="comment">// GNU 2.9</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __true_type this_dummy_member_must_be_first;</span><br><span class="line">  <span class="keyword">typedef</span> __false_type has_trivial_default_constructor;				<span class="comment">// 无关的默认构造函数</span></span><br><span class="line">  <span class="keyword">typedef</span> __false_type has_trivial_copy_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __false_type has_trivial_assignment_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __false_type has_trivial_destructor;						<span class="comment">// 带指针的类需要写析构函数，，否则不需要</span></span><br><span class="line">  <span class="keyword">typedef</span> __false_type is_POD_type;												<span class="comment">// 解决 C 和 C++ 间数据的兼容性；有无关的默认构造函数、析构函数、复制构造函数、移动构造函数、复制赋值运算符、移动赋值运算符；不能含有虚函数和虚父类</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/27/STL-%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/" data-id="cklnwj0hk00006sls5j8q4l7x" data-title="STL 标准模板库" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2021/02/27/C-2-0-%E6%96%B0%E6%A0%87%E5%87%86/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">C++ 2.0 新标准</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/02/27/STL-%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/">STL 标准模板库</a>
          </li>
        
          <li>
            <a href="/2021/02/27/C-2-0-%E6%96%B0%E6%A0%87%E5%87%86/">C++ 2.0 新标准</a>
          </li>
        
          <li>
            <a href="/2021/01/20/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>